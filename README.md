<H2>INFORME</H2>
<p align="center"><img src="img/e.png"/></p>
<H3>1. PLANTEAMIENTO DEL PROBLEMA</H3>
<p align="justify">Node-Red se encarga de visualizar las relaciones, funciones, que permita al usuario programar sin tener que tipear. Además, no solo actúa como herramienta de programación visual, es también un editor de flujo donde podemos añadir o eliminar nodos, para luego conectarlos entre ellos, dándoles el derecho a comunicarse. Esta herramienta, además de tener cantidad de beneficios, es open-source donde se permite gestionar y procesar los datos ingresados en tiempo real, lo cual nos realiza una simplificación gigantesca de todos sus servicios.</p>
HMI, Human Machine Interface, es básicamente un panel del operador, con la cual pueden supervisar, coordinar y controlar los procesos industriales que se ejecuten o los de fabricación de su institución. Cabe tomar en cuenta que la información en tiempo real es propiamente de la HMI, donde proporcionan un conocimiento operacional del proceso y permiten el control, optimización mediante el control de estos.</p>
Python, es un lenguaje de programación multiparadigma, por el hecho de soportar orientación a objetos, programación imperativa, programación funcional. Esta diseñado para ser leído con facilidad, lo que diferencia del demás lenguaje sería el uso de palabras en vez de símbolos, por lo demás sigue siendo open-source.</p>
<H3>2. OBJETIVOS</H3>
<b>Objetivos Generales</b>
<p align="justify">- Realizar un video explicando e identificando los temas relevantes a manera de un tutorial sobre el tema asignado.</p>
- Conocer los beneficios de usar NODE-RED (HMI), Python.</p>
<b>Objetivos Específicos</b>
<p align="justify">-Analizar la utilidad del Dashboard en NODE-RED.</p>
-Implementar un ejemplo que permita visualizar el HMI en NODE-RED.</p>
-Emplear lo aprendido sobre Programación Orientada a Objetos en Python.</p>
-Implementar un ejemplo que permita realizar una calculadora científica en Python.</p>
<H3>3. ESTADO DEL ARTE</H3>
<b>Tecnologías Web en la Industria HMI</b><br>
<p align="justify">Este trabajo se ocupa de las tecnologías web en sistemas HMI industriales. Donde crean, diseñan y desarrollan un marco HMI, que se basa en tecnologías web y en la nube.</p> 
El resultado de este trabajo no es sólo una comparación de las soluciones disponibles, sino también el marco creado y la aplicación de demostración. Su framework se puede utilizar para una aplicación industrial de servidor privado o en la nube. Haciendo que su marco se ajustara y actualice fácilmente. En el cual se desarrollará una aplicación de demostración en el marco, que se basa en la tecnología web y se puede aplicar en dispositivos móviles.(Web technologies in industry HMI (n.d.).2020)</p>
 <b>Desarrollo de un motor de simulación de sistema continuo en python Lenguaje de programación</b><br>
Este artículo retrata el desarrollo de un motor de simulación en lenguaje de programación Python con enfoque en la simulación continua del sistema. Las características del motor se basan en el lenguaje y el software orientados a bloques para la simulación continua del sistema.</p>  
En primer plano el documento describe la necesidad y el uso de dicho motor. En segundo es analizar los conceptos de Python utilizados para la implementación del motor de simulación. Y, por último, este artículo representará la arquitectura del motor, los casos de uso y el uso de los conceptos analizados en el proceso de desarrollo.(Development of a Continuous System Simulation Engine in Python Programing Language (n.d.).2020)</p> 
<b>Internet de las cosas usando Node-Red y Alexa</b>
<p align="justify">El Internet de las cosas significa aprender e interactuar con millones de cosas, incluyendo servicios, sensores, actuadores y muchos otros objetos en Internet.</p>
A medida que aumenta el número de dispositivos en la nube, es necesario actualizar el firmware con más frecuencia. Esto es tedioso. Implica sacar los dispositivos instalados, cambiar el código y parpadear de nuevo. Para superarlos, el procesamiento de datos y la respuesta se puede hacer en otros lugares. Node-Red, una herramienta de cableado visual ayuda a conectar dispositivos con facilidad, lo que resulta en configuraciones de conexión rápidas y sin esfuerzo.(Internet of Things using Node-Red and alexa(n.d.).2020)</p>
<H3>4. MARCO TEORICO</H3>
<p align="justify"><b>Node-Red</p></b>
</p>Fue creada por Nick O’Leary y Dave Conway-Jones del grupo de Servicios de Tecnologías Emergentes de IBM en el año 2013. Su objetivo es dar solución a la complejidad que surge cuando queremos integrar nuestro hardware con otros servicios.</p>
Una herramienta con la cual comunicamos el hardware y servicios, de manera rápida, eficaz. No solo actúa de manera de programación visual, sino se la utiliza para conectar dispositivos de hardware, APIs y servicios de internet. </p>
Node red esta adecuado para los equipos dedicados al internet de las cosas Industrial, personal dedicado al diseño y soluciones para la comunicación que existe en los equipos de planta.</p>
Node-RED está creado a partir de NodeJS y la librería de JavaScript D3.js. Donde NodeJS proporcionara potencia suficiente para que Node-Red pueda ser escalable y fiable. Además de ser un software muy potente que permite que se ejecute programación por medio de JavaScript. Lo componen los nodos, los cuales se arrastran a través de una interfaz gráfica. Todos estos nodos se organizarán en flujos que se conectan entre ellos, todo de manera visual sin tener que generar una línea de código o texto.</p>
<p align="center"><img src="img/1.png"/></p>
<b></p>HMI.</p></b>
<p align="justify">La interfaz hombre máquina, actúa entre el proceso y operadores, es resumen es un panel que lo maneja el operador, o también llamado Dashboard. Este panel que se genera seria la herramienta principal en la que los operadores coordinaran y controlaran los procesos industriales de las instituciones.</p>
La información de operación que genera la institución es traducida al HMI en tiempo real, donde los gráficos ya sean de varias partes físicas o hardware, tomaran su información y la transmitirán, lo cual optimizara el resultado de procesos y su regulación de una manera simplificada al máximo.</p>
En la actualidad, dado que las máquinas y procesos en general están implementadas con controladores y otros dispositivos electrónicos que dejan disponibles puertas de comunicación, es posible contar con sistemas de HMI bastantes más poderosos y eficaces, además de permitir una conexión más sencilla y económica con el proceso o máquinas</p>
<p align="center"><img src="img/2.png"/></p>
<b>Python</p></b>
Es un lenguaje de programación, el cual se lo considera interpretado, por lo mismo funciona en cualquier tipo de sistema que integre su interpretador. Además, ofrece dialectos como el conocido Jython, el cual se usa para escribir en Java.</p>
No solo es multiplataforma y multiparadigma, sino que también nos servirá para resolver códigos para cualquier tipo de medio, como una web o un móvil. Para llevar a cabo todo esto, lo constituye frameworks, los cuales generan ayuda para desarrolladores web, de juegos o científicos. Cabe recalcar que Python es open-source lo cual genera mas ayuda para aquellos que les gusta modificar o distribuir las cosas.</p>
Python, en programación orientada a objetos, trata de modelar lo que se enfrente en función a clases, objetos, usando los conceptos de polimorfismo, herencia, abstracción y más. Lo cual utilizaremos para tratar el rápido aumento en el tamaño y complejidad de sistemas de software.</p>
<p align="center"><img src="img/3.png"/></p>
<H3>5. DIAGRAMAS</H3>
<p align="center"><img src="img/4.jpg"/></p>
<p align="center"><img src="img/5.jpg"/></p>
<p align="center"><img src="img/6.png"/></p>
<H3>6. LISTA DE COMPONENTES</H3>
<b>RaspberryPi</b></p>
•	SoC: Broadcom BCM2835 (CPU, GPU y SDRAM)</p>
•	CPU ARM1176JZF-S a 700 MHz de velocidad de reloj</p>
•	GPU Broadcom VideoCore IV</p>
•	Memoria RAM 512 MB (compartidos con la GPU)</p>
•	2 x USB 2.0</p>
•	1 x Salida audio mini jack 3.5 mm</p>
•	1 x Salida audio/vídeo HDMI</p>
•	1 x Salida vídeo compuesto RCA</p>
•	1 x Micro USB</p></p>
•	1 x RJ45 10/100 Ethernet RJ45</p>
•	Slot SD para tarjeta SD que contendrá el sistema operative y programas</p>
•	Alimentación: 5V/700 mA (3.5 W) vía micro USB</p>
<b>Calculadora científica programada con python para RaspberryPi</b></p>
•	6 resistencias de 4.7k
•	6 interruptores
•	1 Raspberry pi
•	1 Teclado
<H3>7. MAPA DE VARIABLES</H3>
<p align="center"><img src="img/14.png"/></p>
<H3>8. EXPLICACION DEL CODIGO FUENTE</H3>
<b>Calculadora Científica en python</p></b>
#IMPORTACION DE LIBRERIAS
import math
import RPi.GPIO as GPIO
class CalcuCientifica():#CLASES QUE CONTIENE A LA CALCULADORA EN GENERAL
	resultado=0#ATRIBUTO
	def __init__(self,resultado):#CONSTRUCTOR
    	self.resultado=resultado
# menu general del programa
	def menu(self):
    	print("Calculadora Cientifica")
    	print("---------------------------------------------")
    	print("Para la seleccion de funciones use los interruptores unicamente  activado 1 a la vez, despues pulse enter")
    	print("Para el ingreso de numeros use el teclado, despues pulse enter                                        	")
    	print("----------------------------------------------")
    	print("1: Operaciones Basicas\n2: Funciones trigonometricas\n3: Raices,Potencias y Logaritmos\n4: Otros")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	seleccion=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	#SELECTOR DE CASOS PARA DIRIGIRSE A UN SUBMENU
    	if seleccion==1:
        	self.basicas()
    	elif seleccion==2:
        	self.trigonometricas()
    	elif seleccion==3:
        	self.racExpLog()
    	elif seleccion==4:
        	self.otros()
    	else:
        	print("Opcion no valida")
        	self.menu()

#Seccion de operaciones basicas
	def basicas(self):
    	print("Basicas")
    	print("Seleccione opcion a realizar: ")
    	print("1: Suma\n2: Resta\n3: Multiplicacion\n4: Division")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	selBas=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	if selBas==1:
        	self.suma()
    	elif selBas==2:
        	self.resta()
    	elif selBas==3:
        	self.multipli()
    	elif selBas==4:
        	self.division()
    	else:
        	print("Opcion no valida")
        	self.basicas()
#PARA LAS OPERACIONES BASICAS SE PEDIRAN 2 NUMEROS A OPERAR Y EL RESULTADO SE ALMACENARA E IMPRIMIRA
	def suma(self):
    	print("Ingrese el primer numero")
    	num1=float(input())
    	print("Ingrese el segundo numero")
    	num2=float(input())
    	resultado=num1+num2
    	print(num1,'+',num2,'=',resultado)
	def resta(self):
    	print("Ingrese el minuendo")
    	num1=float(input())
    	print("Ingrese el sustraendo")
    	num2=float(input())
    	resultado=num1-num2
    	print(num1,'-',num2,'=',resultado)
	def multipli(self):
    	print("Ingrese el primer numero")
    	num1=float(input())
    	print("Ingrese el segundo numero")
    	num2=float(input())
    	resultado=num1*num2
    	print(num1,'*',num2,'=',resultado)
	def division(self):
    	print("Ingrese el dividendo")
    	num1=float(input())
    	print("Ingrese el divisor")
    	num2=float(input())
    	resultado=num1/num2
    	print(num1,'/',num2,'=',resultado)

#seccion funciones trigonometricas

	def trigonometricas(self):
    	print("Trigonometricas")
    	print("Seleccione tipo de funcion trigonometrica: ")
    	print("1: SENO\n2: COSENO\n3: TANGENTE\n4: ARCOSENO\n5: ARCOCOSENO\n6: ARCOTANGENTE")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	seltri=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	#CASOS PARA REALIZAR DISTINTAS FUNCIONES TRIGONOMETRICAS
    	if seltri==1:
        	self.seno()
    	elif seltri==2:
        	self.coseno()

    	elif seltri==3:
        	self.tangente()

    	elif seltri==4:
        	self.arcoseno()

    	elif seltri==5:
        	self.arcocoseno()

    	elif seltri==6:
        	self.arcotangente()

    	else:
        	print("Opcion no valida")
        	self.trigonometricas()

	#PARA LAS FUNCIONES TRIGONOMETRICAS SE SOLICITAR UN UNICO VALOR DE ANGULO O X A ENCONTRAR Y SE LO ALMACENARA EN UNA VARIABLE LLAMADA ANGULO
	def seno(self):
    	print("Seno(x)")
    	print("Ingrese el valor del angulo x en radianes")
    	angulo=float(input())
    	resultado=math.sin(angulo)
    	print("El seno de ",angulo," es: ",resultado)
	def coseno(self):
    	print("Coseno(x)")
    	print("Ingrese el valor del angulo x en radianes")
    	angulo=float(input())
    	resultado=math.cos(angulo)
    	print("El coseno de ",angulo," es: ",resultado)
	def tangente(self):
    	print("Tangente(x)")
    	print("Ingrese el valor del angulo x en radianes")
    	angulo=float(input())
    	resultado=math.tan(angulo)
    	print("La tangente de ",angulo," es: ",resultado)
	def arcoseno(self):
    	print("ArcoSeno(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.asin(angulo)
    	print("El arcoseno de ",angulo," es el angulo: ",resultado," rad")
	def arcocoseno(self):
    	print("ArcoCoseno(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.acos(angulo)
    	print("El arcocoseno de ",angulo," es el angulo: ",resultado," rad")
	def arcotangente(self):
    	print("ArcoTangente(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.atan(angulo)
    	print("La arcotangente de ",angulo," es el angulo: ",resultado," rad")


#seccion raices exponentes y logaritmos
	def racExpLog(self):
    	print("Raices,Potencias y Logaritmos")
    	print("Seleccione tipo de operacion: ")
    	print("1: Raiz\n2: Potencia\n3: Logaritmo")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	selRacExpLog=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	if selRacExpLog==1:
        	self.raices()
    	elif selRacExpLog==2:
        	self.potencia()
    	elif selRacExpLog==3:
        	self.logaritmos()
    	else:
        	print("Opcion no valida")
        	self.racExpLog()

	#PARA RAICES SE SOLICITARA RADICANDO E INDICE PARA REALIZAR LA OPERACION
	def raices(self):
    	print("Raices")
    	print("Ingrese el indice")
    	indice=int(input())
    	print("Ingrese el radicando")
    	radicando=float(input())
    	resultado=radicando**(1/indice)
    	print("La respuesta de esa raiz es: ",resultado)
	#PARA POTENCIAS SE SOLICITARA BASE Y EXPONENTE PARA REALIZAR LA OPERACION
	def potencia(self):
    	print("Potencias")
    	print("Ingrese la base")
    	base=float(input())
    	print("Ingrese el exponente")
    	exponente=int(input())
    	resultado=base**exponente
    	print("La respuesta de la potencia es: ",resultado)
	#PARA LOS LOGARITMOS PRIMERO SE DEBE ELEGIR EL TIPO DE BASE A OPERAR YA SEA NATURAL O EULER
	#PARA LAS BASES NATURALES SE SOLICITARA EL VALOR DE LA BASE
	#PARA LA BASE EULER UNICAMENTE SE SOLICITARA EL ARGUMENTO
	def logaritmos(self):
    	print("Logaritmos")
    	print("Seleccione el tipo de Logaritmo")
    	print("1: Logaritmo Decimal\n2: Logaritmo Natural")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	selecLog=self.pinSelector()
    	if selecLog==1:
        	self.logB()
    	elif selecLog==2:
        	self.logNat()
    	else:
        	print("Opcion no valida")
        	self.logaritmos()
	def logB(self):
    	print("Logaritmos decimales")
    	print("Ingrese la base:")
    	base=int(input())
    	print("Ingrese el argumento:")
    	argumento=float(input())
    	resultado=math.log(argumento,base)
    	print("El logaritmo base ",base," de ",argumento," es: ",resultado)

	def logNat(self):
    	print("Logaritmos naturales")
    	print("Ingrese el argumento")
    	argumento=float(input())
    	resultado=math.log(argumento,math.e)
    	print("El logaritmo natural de",argumento," es: ",resultado)


#seccion de operaciones
	def otros(self):
    	print("Otras operaciones")
    	print("Seleccione la opcion a realizar")
    	print("1:Factorial de un numero\n2:Valor Absoluto de un numero\n3:Funciones Hiperbolicas")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	selecOtros=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	if selecOtros==1:
        	self.factorial()
    	elif selecOtros==2:
        	self.vabsoluto()
    	elif selecOtros==3:
        	self.hiperbolicas()
    	else:
        	print("Opcion no valida")
        	self.otros()
	#PARA EL NUMERO FACTORIAL SE SOLICITARA AL USUARIO INGRESAR UN VALOR ENTERO UNICAMENTE
	def factorial(self):
    	print("Factorial")
    	print("Ingrese el numero")
    	numerof=int(input())
    	resultado=math.factorial(numerof)
    	print("El factorial de ",numerof," es ",resultado)
	#PARA EL VALOR ABSOLUTO SE SOLICITARA UN NUMERO CUALQUIERA
	def vabsoluto(self):
    	print("Valor Absoluto")
    	print("Ingrese el numero")
    	numero=float(input())
    	resultado=math.fabs(numero)
    	print("El valor absoluto de ",numero," es ",resultado)
	#PARA LAS FUNCIONES HIPERBOLICAS SE SOLICITAR UN VALOR X A ENCONTRAR Y SE LO ALMACENARA EN UNA VARIABLE LLAMADA ANGULO
	def hiperbolicas(self):
    	print("Funciones hiperbolicas")
    	print("Seleccione tipo de funcion hiperbolica: ")
    	print("1: SENO HIPERBOLICO\n2: COSENO HIPERBOLICO\n3: TANGENTE HIPERBOLICA")
    	print("4: ARCOSENO HIPERBOLICO \n5: ARCOCOSENO HIPERBOLICO\n6: ARCOTANGENTE HIPERBOLICA")
    	vacio=input()#VARIABLE VACIA PARA RECIBIR UN ENTER Y PASAR A LA SIGUIENTE INSTRUCCION
    	selecHiper=self.pinSelector()#LLAMADO A LA FUNCION SELECTOR DE PIN PARA LEER EL GPIO
    	#CASOS PARA CADA FUNCION
    	if selecHiper==1:
        	self.senoh()
    	elif selecHiper==2:
        	self.cosenoh()

    	elif selecHiper==3:
        	self.tangenteh()

    	elif selecHiper==4:
        	self.arcosenoh()

    	elif selecHiper==5:
        	self.arcocosenoh()

    	elif selecHiper==6:
        	self.arcotangenteh()

    	else:
        	print("Opcion no valida")
        	self.hiperbolicas()

	def senoh(self):
    	print("Senh(x)")
    	print("Ingrese el valor de x")
    	angulo=float(input())
    	resultado=math.sinh(angulo)
    	print("El seno hiperbolico de ",angulo," es: ",resultado)
	def cosenoh(self):
    	print("Cosh(x)")
    	print("Ingrese el valor de x")
    	angulo=float(input())
    	resultado=math.cosh(angulo)
    	print("El coseno hiperbolico de ",angulo," es: ",resultado)
	def tangenteh(self):
    	print("Tanh(x)")
    	print("Ingrese el valor de x")
    	angulo=float(input())
    	resultado=math.tanh(angulo)
    	print("La tangente hiperbolica de ",angulo," es: ",resultado)
	def arcosenoh(self):
    	print("ArcSenh(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.asinh(angulo)
    	print("El arcoseno hiperbolico de ",angulo," es: ",resultado)
	def arcocosenoh(self):
    	print("ArcCosh(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.acosh(angulo)
    	print("El arcocoseno hiperbolico de ",angulo," es: ",resultado)
	def arcotangenteh(self):
    	print("ArcTanh(x)")
    	print("Ingrese el valor de x ")
    	angulo=float(input())
    	resultado=math.atanh(angulo)
    	print("La arcotangente hiperbolica de ",angulo," es: ",resultado)

	#funciones para raspberry
	#FUNCION PARA INICIAR LOS PUERTOS GPIO COMO ENTRADAS
	def iniciarGPIO(self):
    	GPIO.setmode(GPIO.BOARD)
    	GPIO.setup(3,GPIO.IN)
    	GPIO.setup(5,GPIO.IN)
    	GPIO.setup(7,GPIO.IN)
    	GPIO.setup(11,GPIO.IN)
    	GPIO.setup(13,GPIO.IN)
    	GPIO.setup(15,GPIO.IN)
   	 
	#FUNCION PARA CONTROLAR LOS PINES ACTIVOS
	def pinSelector(self):

    	seleccionador=0
    	#CADA PIN ACTIVO SERA UNA VARIABLE LOGICA QUE SE REGISTRA EN UNA TABLA DE VERDAD
    	#LA VARIABLE SELECCIONADOR GUARDARA EL ESTADO EN EL QUE  TODOS LOS PINES ESTAN MEDIANTE NUMEROS ENTEROS ASIGNADOS
    	#ESTOS NUMEROS SON ASIGNADOS SEGUN LOS BALORES BINARIOS MSI Y LSI PARA CADA PIN
    	#PIN 3=1
    	#PIN 5=2
    	#PIN 7=4
    	#PIN 11=8
    	#PIN 13=16
    	#PIN 15=32

    	if GPIO.input(3) == GPIO.HIGH:
        	seleccionador= seleccionador+1
    	if GPIO.input(5) == GPIO.HIGH:
        	seleccionador= seleccionador+2
    	if GPIO.input(7) == GPIO.HIGH:
        	seleccionador= seleccionador+4
    	if GPIO.input(11) == GPIO.HIGH:
        	seleccionador= seleccionador+8
    	if GPIO.input(13) == GPIO.HIGH:
        	seleccionador= seleccionador+16
    	if GPIO.input(15) == GPIO.HIGH:
        	seleccionador= seleccionador+32
   	 
    	#AQUI SE DETECTA LOS CASOS EN LOS QUE NO HAY PINES QUE RECIBAN UNA SENAL LOGICA O QUE 2 O MAS RECIBAN UNA SENAL LOGICA
    	#SI SE RECIBE UNA UNICA SENAL LOGICA LA FUNCION RETORNARA EL TIPO DE SELECCION QUE SE LE ATRIBUYE AL MENU
    	#SI NO RECIBE UNA UNICA SENAL LOGICA LA FUNCION RETORNARA UN VALOR ALTO QUE NINGUN MENU RECONOCERA
    	if seleccionador == 1:
        	return 1
    	elif seleccionador == 2:
        	return 2
    	elif seleccionador == 4:
        	return 3
    	elif seleccionador == 8:
        	return 4
    	elif seleccionador == 16:
        	return 5
    	elif seleccionador == 32:
        	return 6
    	else:
        	return 100
#PROGRAMA PRINCIPAL
#CREAMOS UN CICLO INFINITO QUE HARA QUE EL PROGRAMA SE REPITA CONSTANTEMENTE
while 1:
  calculo=CalcuCientifica(0)#INICIAMOS LA CLASE
  calculo.iniciarGPIO()#INICIAMOS LOS PUERTOS GPIO
  resultado=calculo.menu()#ATRIBUIMOS UN RESULTADO MEDIANTE LA FUNCION MENU
<H3>9. DESCRIPCION DE PRERREQUISITOS Y CONFIGURACION</H3>
Al ser simulado en create code no es necesario contar con ningún prerrequisito ya que las librerías que se usan ya están incluidas en la página pero si se desea implementar en un raspberry se debe incluir las librerías math y gpio as gpio.</p>
<H3>10. APORTACIONES</H3>
<b>SBC</b></p>
El SBC (Session Border Controller) es un nuevo componente al alcance de las empresas. Se puede instalar como un appliance o máquina virtual y dispone de funcionalidades que harán que su red de telefonía IP sea mucho más segura y se integre mejor con el equipamiento SIP de diferentes fabricantes y proveedores de servicios.
Básicamente, el SBC gestiona tanto la media como la señalización de las llamadas VoIP.
Las funciones principales de un SBC son las siguientes:
•    SEGURIDAD: Uno de los roles principales de estos equipos es proteger, mediante una de capa de seguridad adicional,  los puntos de entrada al sistema de voz ip desde las redes no seguras, evitando el hacking y los fraudes telefónicos. El SBC oculta al exterior la topología de red interna, actuando como un firewall pero con características más adecuadas para el tráfico multimedia.
•    ENCRIPTACIÓN: El uso cada vez más intensivo de las redes públicas para transportar VoIP hace que se incrementen los riesgos de que las comunicaciones puedan ser interceptadas de forma ilícita. Estas amenazas se pueden evitar utilizando los protocolos TLS (Transport Layer Security) y SRTP (Secure Real-Time Transport Protocol) para proteger la señalización y los canales de voz respectivamente. 
•    POLÍTICAS DE ACCESO: El uso no autorizado de los servicios VoIP pueden ser controlados aplicando y gestionando políticas mediante el SBC.
•    ENRUTAMIENTO DE LLAMADAS: El SBC permite configurar reglas de enrutamiento de llamadas que permitirán funcionalidades como el LCR (least cost routing) o el balanceo de carga entre diferentes SIP Trunk.
•    INTEROPERABILIDAD: Aunque SIP se considera un estándar, es extremadamente flexible y la realidad es que dos equipos basados en SIP no necesariamente se comunicaran de forma correcta.
•    MEDIA TRANSCODING: El transcoding es necesario para permitir que diferentes tipos de media crucen a través de equipos diversos y también para permitir un uso óptimo del ancho de banda disponible. Aunque el transcoding se puede hacer enteramente por software requiere un uso intensivo de la CPU y por tanto en sistemas de cierta capacidad es recomendable utilizar transcoding hardware.
•    DETECCIÓN/GENERACIÓN DE DTMF: La señalización DTMF (Dual Tone Multi Frequency) en redes de telefonía IP no siempre es sencilla, ya que algunos codecs no transmiten de forma fiable los tonos debido al uso de algoritmos de compresión con pérdida de ancho de banda que están optimizados para voz. El SBC dispone de la capacidad de implantar correctamente el método estándar RFC2833 para manejar este tipo de señalización(Quarea, s.f.).</p>
<b>Microprosesador</b></p>
Se denomina microprocesador al circuito electrónico que procesa la energía necesaria para que el dispositivo electrónico en que se encuentra funcione, ejecutando los comandos y los programas adecuadamente. La Unidad Central de Procesos (CPU) de una computadora es un ejemplo de un microprocesador.Este componente electrónico forma parte de la tarjeta madre de una computadora y se caracteriza por ser un circuito integrado con miles y, a veces, hasta con millones de transistores.Se denomina micro por su significado inglés que indica “pequeño”, en relación a la importancia de su función en un dispositivo, comparado a veces con el cerebro y con el corazón de los seres humanos.Este componente electrónico es el encargado de procesar y ejecutar las instrucciones codificadas en números binarios.El microprocesador es comúnmente conocido como la Unidad Central de Procesos (CPU) de los diferentes dispositivos electrónicos, pero también contienen procesadores otros dispositivos como los discos duros.Es tan importante la función del microprocesador que actualmente es considerado el componente electrónico más influyente en la vida del ser humano.A nivel económico, es el producto más comercializado a nivel mundial y, a nivel social, es el objeto más utilizado, presente en una gran variedad de artefactos y componentes electrónicos, así como, computadores, teléfonos celulares, teléfonos inteligentes y tabletas(Microprocesador, 2020).</p>
<H3>11. CONCLUSIONES</H3></p>
-Realizada la investigación sobre las tarjetas de desarrollo  se llegó a las conclusiones sobre los objetivos específicos las cuales fueron:</p>
-Mediante la investigación y la implementación de los ejemplos mostrados en clase además de otros ejemplos implementados de manera propia nos ayudo a conocer cómo funcionan los distintos parámetros de la programación orientada a objetos.</p>
-Los nodos presentes en la dashboar creada para la realización de este proyecto son varios los cuales se describieron brevemente en varios de los elementos mostrados anteriormente.</p>
-Se implementó de manera exitosa una calculadora científica  gracias a los estudios realizados en clase y las investigaciones extra, además se logró identificar los parámetros necesarios para el paradigma de programación orientada a objetos</p>
-Durante el desarrollo de la implementación de la dashboar se mostró que varios de los elementos empleados son útiles y necesarios en varias actividades y negocios populares en la actualidad</p>
-Después de haber logrado los objetivos específicos se llegó a la conclusión que gracias a estos objetivos específicos se lograra llegar a la implementación y la realización de los objetivos generales.</p>
-Mediante la implantación de las dashboard se logró conocer la funcionalidad de cada uno de los nodos necesarios para su configuración.</p>
-Se logró manejar de manera satisfactoria el paradigma de programación orientada a objetos sobre todo para la implementación de la calculadora científica hecha en el lenguaje de programación Python.</p>
<H3>12. RECOMENDACIONES</H3></p>
-Al momento de realizar la investigación nos mostró que se deben estudiar más afondo la generación de las dashboard ya que las  mismas son muy útiles en algunos de los negocios que actualmente están en auge.</p>
-Conocer los distintos tipos de paradigmas de programación que existen y en especial en los lenguajes de programación que son más utilizados en la actualidad.</p>
<H3>13. CRONOGRAMA</H3>
<p align="center"><img src="img/cro.png"/></p>
<H3>14. BIBLIOGRAFIA</H3>
- García Jiménez, S. (2019). Desarrollo de paneles de control para redes IoT basados en NodeRed (Doctoraldissertation).</p>
- OpenJS Foundation. (Julio de 2020). Node-RED .Obtenido de https://flows.nodered.org/node/node-red-dashboard</p>
-(20 de 11 de 2018). Obtenido de Aprendiendo Arduino:https://aprendiendoarduino.wordpress.com /2018/11/20 node-red</p>
-Sicari, S., Rizzardi, A., & Coen-Porisini, A. (2019).Smart transport and logistics: A Node-RED</p>
implementation. Internet Technology Letters, 2(2), e88.5</p>
-García Jiménez, S. (2019). Desarrollo de paneles de control para redes IoT basados en NodeRed (Doctoral dissertation).</p>
- Lutvi, L. (2019). PERANCANGAN DANIMPLEMENTASI DASHBOARD BERBASIS NODE-RED UNTUK MONITORING TEGANGAN,ARUS, DAYA, DAN SUHU DENGAN MEMANFAATKAN KOMUNIKASI ARDUINO DAN LORA. Program Studi Teknik Elektro.</p>
- Dashboard Nodes. (2018). Hewlett Packard Enterprise.https://techlibrary.hpe.com/docs/otlink-wo/Dashboard-Nodes.html#DashboardNodes-ChartNode</p>
-Los nodos centrales. (2020). Node-RED.https://nodered.org/docs/user-guide/nodes#template</p>
-Notificaciones Node-Red. (2016).HEIMDALL-EYE.http://heimdall-eye.es/notificaciones-node-red/</p>
- 2009 Avelino Amoedo, Mara del Pilar Martnez-Costa, Elsa Moreno10.1386/rajo.6.1.5_4 Radio Journal:International Studies in Broadcast & Audio Media</p>
-ENSEÑANZA DE CURSOS DE LA PROGRAMACIÓN ORIENTADA A OBJETOS PARA LOS PRINCIPIANTES 2011 Elzbieta Malinowski Gadja 10.15517/ring.v9i1-2.7731Revista Ingeniería</p>
Fuente: Web technologies in industry HMI - IEEE Conference Publication. (n.d.). Recuperado en Agosto 3, 2020, de https://ieeexplore.ieee.org/document/7329647</p>
Fuente: Development of a Continuous System Simulation Engine in Python Programing Language - IEEE Conference Publication. (n.d.). Recuperado en Agosto 3, 2020, de https://ieeexplore.ieee.org/document/9066334</p>
Fuente: Internet of Things using Node-Red and alexa - IEEE Conference Publication. (n.d.). Recuperado en Agosto 3, 2020, de https://ieeexplore.ieee.org/document/8261194</p>

<H3>15. ANEXOS</H3>
<H3>15.1 MANUAL DE USUARIO</H3>
<H3>15.2 HOJAS TECNICAS</H3>
